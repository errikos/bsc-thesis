% demo.tex
%
% Enjoy, evolve, and share!
%
% Compile it as follows:
%   latexmk
%
% Check file `dithesis.cls' for other configuration options.
%
\documentclass[inscr,ack,preface]{dithesis}

%\usepackage{graphicx}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%% User-specific package inclusions %%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{enumerate}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\hypersetup{
    unicode=true,                     % non-Latin characters in bookmarks
    pdffitwindow=true,                % page fit to window when opened
    pdfnewwindow=true,                % links in new window
    pdfkeywords={},                   % list of keywords
    colorlinks=true,                  % false: boxed links; true: colored links
    linkcolor=black,                  % color of internal links
    citecolor=black,                  % color of links to bibliography
    filecolor=black,                  % color of file links
    urlcolor=black,                   % color of external links
    pdftitle={Constructive Negation in Higher-Order Logic Programming},
    pdfauthor={Ergys Dona},           % author
    pdfsubject={Logic Programming}    % subject of the document
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%% User-specific package inclusions %%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{definition}
\newtheorem{definition}{Definition}[]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%% User-specific configuration %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%% User-specific configuration %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\hcn}{$\mathcal{H}_\mathsf{cn}$}
\newcommand{\msf}[1]{$\mathsf{#1}$}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%% Required Metadata %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% First name, last name
%
\authorFirstGr{Εργκύς}
\authorFirstAbrGr{Ε.} % abbreviation of first name
\authorMiddleGr{Α.}   % abbreviation of father's first name
\authorLastGr{Ντόνα}
\authorFirstEn{Ergys}
\authorFirstAbrEn{E.}
\authorMiddleEn{A.}
\authorLastEn{Dona}
\authorSn{1115200900148}

%
% The title of the thesis
%
\titleEn{Implementation of Constructive Negation in Extensional Higher-Order Logic Programming}
\titleGr{Υλοποίηση Κατασκευαστικής Άρνησης σε Εκτατικό Λογικό Προγραμματισμό Υψηλής Τάξης}

%
% Month followed by Year
%
\dateGr{ΙΟΥΝΙΟΣ 2017}
\dateEn{JUNE 2017}

%
% Supervisor(s) info
%
\supervisorGr{Πάνος Ροντογιάννης}{Καθηγητής ΕΚΠΑ}
\supervisorGr{Άγγελος Χαραλαμπίδης}{ΕΚΕΦΕ «Δημόκριτος»}
\supervisorEn{Panos Rondogiannis}{NKUA Professor}
\supervisorEn{Angelos Charalambidis}{N.C.S.R. ``Demokritos''}

%
% Abstract, synopsis, inscription, ack, and preface pages.
%
\abstractEn{
  \begin{greek}
    Η περίληψη, η επιστημονική περιοχή και οι λέξεις κλειδιά στα Αγγλικά. Δεν θα πρέπει να υπερβαίνει τη μία σελίδα.
  \end{greek}
}

\abstractGr{
  \begin{greek}
    Η περίληψη περιλαμβάνει το σκοπό-αντικείµενο της εργασίας, τη μεθοδολογία, τα κύρια βήματα που ακολουθήθηκαν και τέλος τα κύρια αποτελέσματα. Μετά το τέλος της περίληψης θα δηλώνεται η επιστημονική περιοχή της εργασίας και 5 λέξεις κλειδιά. Η συνολική έκταση της περίληψης και των λέξεων δήλωσης επιστημονικής περιοχής και λέξεων-κλειδιών θα είναι μέχρι µία σελίδα. Δεν θα πρέπει να υπερβαίνει τη μία σελίδα.
  \end{greek}
}

\acksEn{
  \begin{greek}
    Στη σελίδα αυτή αναφέρονται οι ευχαριστίες. Η σελίδα αυτή είναι προαιρετική. Παρατίθεται παράδειγμα ευχαριστιών.

    Για τη διεκπεραίωση της παρούσας Πτυχιακής Εργασίας, θα θέλαμε να ευχαριστήσουμε τους επιβλέποντες, αν. καθ .Ευστράτιο Γεωργιάδη, Γρηγόριο Παπάμαλο, Αναστασία Γούσιου, Ξενοφών Παπαδόπουλο, για τη συνεργασία και την πολύτιμη συμβολή του στην ολοκλήρωση της.
  \end{greek}
}

\prefaceEn{
  This thesis constitutes my final step towards completing the undergraduate degree programme in the Department of Informatics and Telecommunications of the National and Kapodistrian University of Athens. It was carried out while working full-time in CERN, which added to the challenge.

  During the process of selecting and taking up a thesis subject, I encountered many interesting topics and had discussions with many professors. I would like to thank them all for their patience, cooperation and tips.

  The reason for selecting the current subject was that it was fascinating at first sight. I was no stranger to classical logic programming, however the concept of higher-order logic programming was something new for me.

  \hcn{} is a really expressive language. Its higher-order semantics allow one to write even some of the most complex predicates in a very elegant fashion. Of course the main property that enables such elegance is constructive negation, which is the principal feature of \hcn{}.

  \hcn{} borrows the semantics of constructive negation as defined by David Chan for the first-order case. It adapts them to the higher-order semantics of itself and does so perfectly in a theoretical level. However, implementing \hcn{} turned out to be a more challenging task than anticipated. The motivation behind this thesis is the identification and redefinition of those characteristics of the higher-order language \hcn{} that make it difficult for it to be implemented correctly.

  A correct implementation of \hcn{} shall then enable a whole world of applications to demonstrate themselves in solving interesting problems.
}

\inscriptionEn{\emph{To my family.}}

%
% Subject area and keywords
%
\subjectAreaGr{Λογικός Προγραμματισμός}
\subjectAreaEn{Logic Programming}
\keywordsGr{λογική, προγραμματισμός, άρνηση, υψηλή τάξη, εκτατικός}
\keywordsEn{logic, programming, negation, high-order, extensional}

%
% Set the .bib file containing your paper publications (leave the extension out)
%
% This is optional, but it should be specified when option 'lop' is passed to
% the document class.
%
% Then, inside the document environment, you may use the command '\nocitelop' to
% site your papers, as you would traditionally do with the commands '\cite' or
% '\nocite'.
%
% The papers are printed in reverse chronological order.
%
%\lopfile{mypapers/pubs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%% Required Metadata %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\frontmatter

\mainmatter

\chapter{INTRODUCTION}

This is the introduction...

\chapter{THE HIGHER-ORDER LANGUAGE \hcn}

\section{Preliminaries}
The reader is presumed to be familiar with the basic concepts and definitions of classical Logic Programming \cite{Lloyd:1987:FLP:39279}. For example, the concepts \textbf{term}, \textbf{formula}, \textbf{atom}, \textbf{(program) clause} and \textbf{goal} are defined as in classical Logic Programming, with slight extensions on their definitions where necessary. On the other hand, we will give specialised definitions for the concepts of \textbf{interpretation} and \textbf{model} and extend them where necessary as well.

\section{Basic Definitions}

\definition The types of \hcn{} are defined as follows:

\begin{center}
  \begin{tabular}{llll}
    $\sigma$ & $:=$ & $\iota ~~|~ \left( \iota \rightarrow \sigma \right)$ & \hspace*{2.5cm} \emph{(functional)} \\
    $\rho$   & $:=$ & $\iota ~~|~ \pi$ & \hspace*{2.5cm} \emph{(argument)} \\
    $\pi$    & $:=$ & $o ~~|~ \left( \rho \rightarrow \pi \right)$ & \hspace*{2.5cm} \emph{(predicate)} \\
  \end{tabular}
\end{center}

The argument type $\rho$ consists of the following subtypes:

\begin{center}
  \begin{tabular}{llll}
    $\mu$    & $:=$ & $\iota ~~|~ \kappa$ & \hspace*{2.5cm} \emph{(existential)} \\
    $\kappa$ & $:=$ & $\iota \rightarrow o ~~|~ \left( \iota \rightarrow \kappa \right)$ & \hspace*{2.5cm} \emph{(set)} \\
  \end{tabular}
\end{center}

\chapter{THE PROOF PROCEDURE}

\section{Single step derivation}

\begin{definition}{\emph{Single-step derivation}}

Let \msf{P} be a program and let \msf{G_{k}} and \msf{G_{k+1}} be goal clauses.

Let \msf{G_{k}} be a conjunction \msf{\leftarrow A_1 \land \dots \land A_n}, where each \msf{A_i} is a body expression of type \msf{o}.

Let \msf{A_i} be one of \msf{A_1, \ldots, A_n} and let us call it the \emph{selected expression}.

Let \msf{A' = A_1 \land \dots \land A_{i-1} \land A_{i+1} \land \dots \land A_n}.

We say that \msf{G_{k+1}} \emph{is derived in one step} from \msf{G_k} using \msf{\theta}, if one of the following conditions applies:

\begin{enumerate}
  \item if \msf{A_i} is \msf{true} and \msf{n > 1},
        then \msf{G_{k+1} = \leftarrow A'} is derived from \msf{G_k}
        using \msf{\theta = \epsilon};
  \item if \msf{A_i} is \msf{\left( E_1 \lor E_2 \right)},
        then \msf{G_{k+1} = \leftarrow A_1 \land \dots \land E_j \land \dots \land A_n} is derived from \msf{G_k}
        using \msf{\theta = \epsilon}, where \msf{j \in \{1,2\}};
  \item if \msf{A_i} is \msf{\left( \exists V ~ E \right)},
        then \msf{G_{k+1} = \leftarrow A_1 \land \dots \land E \land \dots \land A_n} is derived from \msf{G_k} using \msf{\theta = \epsilon};
  \item if \msf{A_i \rightsquigarrow A_i'},
        then \msf{G_{k+1} = \leftarrow A_1 \land \dots \land A_i' \land \dots \land A_n} is derived from \msf{G_k} using \msf{\theta = \epsilon};
  \item if \msf{A_i} is \msf{\left( E_1 \approx E_2 \right)},
        then \msf{G_{k+1} = \leftarrow A' \theta} is derived from \msf{G_k} using \msf{\theta = mgu \left( E_1, E_2 \right)};
  \item if \msf{A_i} is \msf{\left( R ~ \widehat{E} \right)}
        and \msf{R} is a predicate variable of type \msf{\kappa}
        then \msf{G_{k+1} = \leftarrow A' \theta} is derived from \msf{G_k}
        using \msf{\theta = \left\{ R \middle/ \left( \lambda \widehat{X} . \left( \widehat{X} \approx \widehat{E} \right) \bigvee_{\kappa} R' \right) \right\}},
        where \msf{R'} is a fresh predicate variable of type \msf{\kappa};
  \item if \msf{A_i} is \msf{\sim \exists \widehat{V} ~ E}
        and \msf{A_i} is negatively reduced to \msf{A_i'},
        then \msf{G_{k+1} = \leftarrow A_1 \land \dots \land A_i' \land \dots \land A_n} is derived from \msf{G_k} using \msf{\theta = \epsilon};
  \item if \msf{A_i} is \msf{\sim \exists \widehat{V} \left( R ~ \widehat{E} \right)}
        and \msf{R} is a predicate variable of type \msf{\kappa}
        and \msf{R \not\in \widehat{V}},
        then \msf{G_{k+1} = \leftarrow A' \theta} is derived from \msf{G_k}
        using \msf{\theta = \left\{ R \middle/ \left( \lambda \widehat{X} . \sim \exists \widehat{V} \left( \widehat{X} \approx \widehat{E} \right) \bigwedge_{\kappa} R' \right) \right\}},
        where \msf{R'} is a fresh predicate variable of type \msf{\kappa};
  \item is \msf{A_i} is \msf{\sim \exists \widehat{V} \sim \left( R ~ \widehat{E} \right)}
        and \msf{R} is a predicate variable of type \msf{\kappa}
        and \msf{R \not\in \widehat{V}},
        then \msf{G_{k+1} = \leftarrow A' \theta} is derived from \msf{G_k}
        using \msf{\theta = \left\{ R \middle/ \left( \lambda \widehat{X} . ~ \exists \widehat{V} \left( \widehat{X} \approx \widehat{E} \right) \bigvee_{\kappa} R' \right) \right\}}.
\end{enumerate}

\end{definition}


\section{Reduction}
\begin{definition}{\emph{Reduction}}

Let \msf{P} be a program and \msf{E}, \msf{E'} be body expressions of type \msf{o}.

We say that \msf{E} is reduced (with respect to \msf{P}) to \msf{E'} (denoted as \msf{E \rightsquigarrow E'}) if one of following conditions applies:

\begin{enumerate}
  \item \msf{p ~ \widehat{A} \rightsquigarrow E ~ \widehat{A}}, where \msf{E} is the completed expression for \msf{p} with respect to \msf{P};
  \item \msf{\left( \lambda X. E \right) B ~ \widehat{A} \rightsquigarrow E\left\{ X / B \right\} \widehat{A}};
  \item \msf{\left( E_1 \bigvee_{\pi} E_2 \right) \widehat{A} \rightsquigarrow \left( E_1 ~ \widehat{A} \right) \lor_{o} \left( E_2 ~ \widehat{A}  \right)};
  \item \msf{\left( E_1 \bigwedge_{\pi} E_2 \right) \widehat{A} \rightsquigarrow \left( E_1 ~ \widehat{A} \right) \land_{o} \left( E_2 ~ \widehat{A}  \right)}.
\end{enumerate}

\end{definition}

\section{Negative Reduction}
\begin{definition}{\emph{Negative reduction}}

Let \msf{P} be a program and \msf{B}, \msf{B'} be body expressions where \msf{B = \sim \exists \widehat{U} \left( A_1 \land \dots \land A_n \right)} and each \msf{A_i} is a body expression except for conjunction.

Let \msf{A_i} be the selected expression and \msf{A' = A_1 \land \dots \land A_{i-1} \land A_{i+1} \land \dots \land A_n}.

Then, we say that \msf{B} is \emph{negatively-reduced} to \msf{B'} if one of the following conditions applies:

\begin{enumerate}
  \item if \msf{A_i} is \msf{false}, then \msf{B' = true};
  \item if \msf{A_i} is \msf{true} and \msf{n = 1}, then \msf{B' = false},
        else \msf{B' = \sim \exists \widehat{U} ~ A'};
  \item if \msf{A_i} is \msf{\left( E_1 \lor E_2 \right)},
        then \msf{B' = B_1' \land B_2'}, \\ where \msf{B_j' = \sim \exists \widehat{U} \left( A_1 \land \dots \land E_j \land \dots \land A_n \right)}, for \msf{j \in \{ 1, 2 \}};
  \item if \msf{A_i} is \msf{\left( \exists V ~ E \right)},
        then \msf{B' = \sim \exists \widehat{U} V \left( A_1 \land \dots \land E \land \dots \land A_n \right)};
  \item if \msf{A_i \rightsquigarrow A_i'},
        then \msf{B' = \sim \exists \widehat{U} \left( A_1 \land \dots \land A_i' \land \dots \land A_n \right)};
  \item if \msf{A_i} is \msf{\left( E_1 \approx E_2 \right)}, then:
        \begin{enumerate}
          \item if \msf{\sim \exists \widehat{U} \left( E_1 \approx E_2 \right)}
                is valid, then \msf{B' = true};
          \item if \msf{\sim \exists \widehat{U} \left( E_1 \approx E_2 \right)}
                is non-valid and neither \msf{E_1} nor \msf{E_2} is a variable,
                \\then \msf{B' = \sim \exists \widehat{U} \left( A_1 \land \dots \land A_{i-1} \land \left( \widehat{X} \approx \widehat{X} \theta \right) \land A_{i+1} \land \dots \land A_n \right)},
                \\where \msf{\theta = unify \left( E_1, E_2 \right)} and \msf{\widehat{X} = dom\left( \theta \right)};
          \item if \msf{\sim \exists \widehat{U} \left( E_1 \approx E_2 \right)} is unsatisfiable and either \msf{E_1} or \msf{E_2} is a variable in \msf{\widehat{U}},
          \\then \msf{B' = \sim \exists \widehat{U} \left( A' \theta \right)}, where \msf{\theta = \{ X / E \}} and \msf{X} is the one expression that is a variable in \msf{\widehat{U}} and \msf{E} is the other;
          \item if \msf{\sim \exists \widehat{U} \left( E_1 \approx E_2 \right)}
                is primitive and \msf{n > 1}, \\
                then \msf{B' = \sim \exists \widehat{U}_1 ~ A_i \lor \exists \widehat{U}_1 \left( A_i ~\land \sim \exists \widehat{U}_2 ~ A' \right)}, where \msf{\widehat{U}_1} are the variables in \msf{\widehat{U}} that are free in \msf{A_i} and \msf{\widehat{U}_2} are the variables in \msf{\widehat{U}} not in \msf{\widehat{U}_1};
        \end{enumerate}
  \item if \msf{A_i} is \msf{\left( R ~ \widehat{E} \right)} and \msf{R} is a predicate variable, then:
        \begin{enumerate}
          \item if \msf{R \in \widehat{U}},
                then \msf{B' = \sim \exists \widehat{U}' \left( A' \theta \right)},
                where substitution \msf{\theta = \left\{ R \middle/ \left( \lambda X . \left( X \approx E \right) \bigvee_{\kappa} R' \right) \right\}}, \msf{R'} is a predicate variable of the same type as \msf{R} and \msf{\widehat{U}'} is the same as \msf{\widehat{U}}, only the variable \msf{R} has been replaced with \msf{R'};
          \item if \msf{R \not \in \widehat{U}} and \msf{n > 1},
                then \msf{B' = \sim \exists \widehat{U}_1 ~ A_i \lor \exists \widehat{U}_1 \left( A_i ~\land \sim \exists \widehat{U}_2 ~ A' \right) \land B},
                where \msf{\widehat{U}_1} are the variables in \msf{\widehat{U}} that are free in \msf{A_i} and \msf{\widehat{U}_2} are the variables in \msf{\widehat{U}} not in \msf{\widehat{U}_1};
        \end{enumerate}
  \item if \msf{A_i} is \msf{\sim \exists \widehat{V} ~ E} and \msf{A_i} is negatively-reduced to \msf{A_i'}, \\
        then \msf{B' = \sim \exists \widehat{U} \left( A_1 \land \dots \land A_i' \land \dots \land A_n \right)};
  \item if \msf{A_i} is a primitive inequality \msf{\sim \exists \widehat{V} \left( E_1 \approx E_2 \right)}, then:
        \begin{enumerate}
          \item if \msf{A_i} contains free variables in \msf{\widehat{U}} and \msf{A'} is a conjunction of primitive inequalities, then \msf{B' = \sim \exists \widehat{U} ~ A'};
          \item if \msf{A_i} does not contain any free variables in \msf{\widehat{U}}, then \msf{B' = \exists \widehat{V} \left( E_1 \approx E_2 \right) \lor \sim \exists \widehat{U} ~ A'};
        \end{enumerate}
  \item if \msf{A_i} is \msf{\sim \exists \widehat{V} \left( R ~ \widehat{E} \right)} and \msf{R \not\in \widehat{V}} is a predicate variable,
        then:
        \begin{enumerate}
          \item if \msf{R \in \widehat{U}},
                then \msf{B' = \sim \exists \widehat{U'} \left( A' \theta \right)},
                where substitution \\ \msf{\theta = \left\{ R \middle/ \left( \lambda X . \sim \exists \widehat{V} \left( X \approx E \right) \bigwedge_{\kappa} R' \right) \right\}},
                \msf{R'} is a predicate variable of the same type \msf{\kappa} as \msf{R}
                and \msf{\widehat{U}'} is the same as \msf{\widehat{U}}, only the variable \msf{R} has been replaced with \msf{R'};
          \item if \msf{R \not\in \widehat{U}} and \msf{n > 1},
                then \msf{B' = \sim \exists \widehat{U}_1 ~ A_i \lor \exists \widehat{U}_1 \left( A_i ~ \land \sim \exists \widehat{U}_2 ~ A' \right) \land B},
                where \msf{\widehat{U}_1} are the variables in \msf{\widehat{U}} that are free in \msf{A_i} and \msf{\widehat{U}_2} are the variables in \msf{\widehat{U}} not in \msf{\widehat{U}_1};
          \item if \msf{R \not\in \widehat{U}}, \msf{n = 1} and \msf{\widehat{V}} is non-empty, \\
                then \msf{B' = \exists \widehat{V} \sim \exists \widehat{U} \left( \sim \left( R ~ \widehat{E} \right) \land \sim \exists \widehat{V}' \left( R ~ \widehat{E}' \right) \right)};
        \end{enumerate}
  \item if \msf{A_i} is \msf{\sim \exists \widehat{V} \sim \left( R ~ \widehat{E} \right)} and \msf{R} is a predicate variable and \msf{R \not\in \widehat{V}}, then:
        \begin{enumerate}
          \item if \msf{R \in \widehat{U}},
                then \msf{B' = \sim \exists \widehat{U}' \left( A' \theta \right)},
                where substitution \\ \msf{\theta = \left\{ R \middle/ \left( \lambda X . \exists \widehat{V} \left( X \approx E \right) \bigvee_{\kappa} R' \right) \right\}},
                \msf{R'} is a predicate variable of the same type \msf{\kappa} as \msf{R} and \msf{\widehat{U}'} is the same as \msf{\widehat{U}}, only the variable \msf{R} has been replaced with \msf{R'};
          \item if \msf{R \not\in \widehat{U}} and \msf{n > 1},
                then \msf{B' = \sim \exists \widehat{U}_1 ~ A_i \lor \exists \widehat{U}_1 \left( A_i ~ \land \sim \exists \widehat{U}_2 ~ A' \right) \land B};
          \item if \msf{R \not\in \widehat{U}}, \msf{n = 1} and \msf{\widehat{V}} is non-empty, \\
                then \msf{B' = \exists \widehat{V} \sim \exists \widehat{U} \left( \left( R ~ \widehat{E} \right) \land \sim \exists \widehat{V}' \sim \left( R ~ \widehat{E}' \right) \right)}.
        \end{enumerate}
\end{enumerate}

\end{definition}

\backmatter

% abbreviations table
\abbreviations
\begin{center}
	\renewcommand{\arraystretch}{1.5}
	\begin{longtable}{ l @{\qquad} l }
	\toprule
	RDF    & Resource Description Framework \\
	SPARQL & SPARQL Protocol and RDF Query Language \\
	OWL    & Web Ontology Language \\
	OGC    & Open Geospatial Consortium \\
	\bottomrule
	\end{longtable}
\end{center}

% appendix
\begin{appendix}
% mark the beginning of the appendix
\appendixstartedtrue

% add appendix line to ToC
\phantomsection
\addcontentsline{toc}{chapter}{APPENDICES}

\chapter{FIRST APPENDIX}

\end{appendix}

% manually include the bibliography
\bibliographystyle{plain}
\bibliography{references}
% include it also in ToC (do sth on your own)
\addcontentsline{toc}{chapter}{REFERENCES}

\end{document}
