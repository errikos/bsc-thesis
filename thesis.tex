% demo.tex
%
% Enjoy, evolve, and share!
%
% Compile it as follows:
%   latexmk
%
% Check file `dithesis.cls' for other configuration options.
%
\documentclass[inscr,ack,preface]{dithesis}

%\usepackage{graphicx}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%% User-specific package inclusions %%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{listings}
\lstset{%
  basicstyle=\ttfamily\footnotesize,
  breaklines=true,
}

\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{enumerate}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\hypersetup{
    unicode=true,                     % non-Latin characters in bookmarks
    pdffitwindow=true,                % page fit to window when opened
    pdfnewwindow=true,                % links in new window
    pdfkeywords={},                   % list of keywords
    colorlinks=true,                  % false: boxed links; true: colored links
    linkcolor=black,                  % color of internal links
    citecolor=black,                  % color of links to bibliography
    filecolor=black,                  % color of file links
    urlcolor=black,                   % color of external links
    pdftitle={Implementation of Constructive Negation in Higher-Order Logic Programming},
    pdfauthor={Ergys Dona},           % author
    pdfsubject={Logic Programming}    % subject of the document
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%% User-specific package inclusions %%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{definition}
\newtheorem{definition}{Definition}[]
\newtheorem{example}{Example}[chapter]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%% User-specific configuration %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%% User-specific configuration %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\h}{$\mathcal{H}$}
\newcommand{\hcn}{$\mathcal{H}_\mathsf{cn}$}
\newcommand{\msf}[1]{$\mathsf{#1}$}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%% Required Metadata %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% First name, last name
%
\authorFirstGr{Εργκύς}
\authorFirstAbrGr{Ε.} % abbreviation of first name
\authorMiddleGr{Α.}   % abbreviation of father's first name
\authorLastGr{Ντόνα}
\authorFirstEn{Ergys}
\authorFirstAbrEn{E.}
\authorMiddleEn{A.}
\authorLastEn{Dona}
\authorSn{1115200900148}

%
% The title of the thesis
%
\titleEn{Implementation of Constructive Negation in Extensional Higher-Order Logic Programming}
\titleGr{Υλοποίηση Κατασκευαστικής Άρνησης σε Εκτατικό Λογικό Προγραμματισμό Υψηλής Τάξης}

%
% Month followed by Year
%
\dateGr{ΙΟΥΝΙΟΣ 2017}
\dateEn{JUNE 2017}

%
% Supervisor(s) info
%
\supervisorGr{Πάνος Ροντογιάννης}{Καθηγητής ΕΚΠΑ}
\supervisorGr{Άγγελος Χαραλαμπίδης}{Ερευνητής ΕΚΕΦΕ «Δημόκριτος»}
\supervisorEn{Panos Rondogiannis}{NKUA Professor}
\supervisorEn{Angelos Charalambidis}{N.C.S.R. ``Demokritos'' Researcher}

%
% Abstract, synopsis, inscription, ack, and preface pages.
%
\abstractEn{
  \begin{english}
    Constructive negation is a logic programming negation method that allows the handling of non-ground negative literals. Logic programming systems which are enhanced with constructive negation may produce not only equalities (assignments or unifications of variables), but also inequalities, that, roughly speaking, restrict variables to be different from some value.

    Extensional higher-order logic programming is a logic programming paradigm that extends classical (first-order) logic programming by introducing higher-order terms, while preserving all the well-known properties of the former.

    An extensional higher-order logic programming language called HOPES (\h{}) has been recently proposed. \h{} has been enhanced with constructive negation to create \hcn{} (HOPES with constructive negation).

    While the foundations of \hcn{} are based on strong and well-defined semantics, implementing a logic programming system (interpreter) for it proved to be a real challenge. The reason is that the enhanced definition of the \hcn{} proof procedure does not define any particular method for selecting the next subgoal to be satisfied. We show that, while the language definition guarantees that there exist paths in the proof tree that lead to correct answers, if a naive selection policy (e.g. always selecting the left-most literal, like PROLOG does) is adopted, then one has to take extra measures in order to avoid following paths that will never lead to correct solutions.

    The contribution of this thesis consists of the redefinition of some of the rules in the \hcn{} proof procedure. We show that the redefined proof procedure allows the implementation of an interpreter for \hcn{}, which follows the left-most derivation rule of PROLOG and behaves correctly (only gives correct answers) for any given query.
  \end{english}
}

\abstractGr{
  \begin{greek}
    Η κατασκευαστική άρνηση είναι μια μέθοδος άρνησης στον λογικό προγραμματισμό, η οποία επιτρέπει το χειρισμό μη-συγκεκριμενοποιημένων αρνητικών προτάσεων. Τα συστήματα λογικού προγραμματισμού τα οποία είναι επαυξημένα με κατασκευαστική άρνηση μπορούν δυνητικά να παράγουν όχι μόνο ισότητες (αναθέσεις ή ενοποιήσεις μεταβλητών), αλλά και ανισότητες, οι οποίες, γενικά μιλώντας, περιορίζουν τις μεταβλητές έτσι ώστε να είναι διαφορετικές από κάποια τιμή.

    Ο εκτατικός λογικός προγραμματισμός υψηλής τάξης είναι ένα παράδειγμα λογικού προγραμματισμού που επεκτείνει τον κλασικό (πρώτης τάξης) λογικό προγραμματισμό εισάγοντας όρους υψηλής τάξης, ενώ παράλληλα διατηρεί τις καλά ορισμένες ιδιότητες του προηγούμενου.

    Μια γλώσσα λογικού προγραμματισμού υψηλής τάξης με όνομα HOPES (\h{}) έχει προταθεί πρόσφατα. Η γλώσσα αυτή έχει επαυξηθεί με κατασκευαστική άρνηση για να διαμορφωθεί η γλώσσα \hcn{} (HOPES with constructive negation).

    Ενώ η σημασιολογία της \hcn{} είναι καλά ορισμένη, η υλοποίηση ενός συστήματος λογικού προγραμματισμού (διερμηνευτή) για την τελευταία αποδείχθηκε μια πραγματική πρόκληση. Ο λόγος είναι πως η διαδικασία απόδειξης της \hcn{} δεν υποδεικνύει κανέναν συγκεκριμένο τρόπο επιλογής του επόμενου στόχου για ικανοποίηση. Δείχνουμε πως, ενώ ορισμός της γλώσσας εγγυάται την ύπαρξη μονοπατιών στο δέντρο απόδειξης, τα οποία οδηγούν σε σωστές λύσεις, εάν μια απλοϊκή πολιτική επιλογής (π.χ. η επιλογή πάντα του αριστερότερου υποστόχου, όπως κάνει η PROLOG) έχει υιοθετηθεί, τότε πρέπει να παρθούν επιπλέον μέτρα έτσι ώστε η υλοποίηση να αποφύγει μονοπάτια τα οποία δεν θα οδηγήσουν ποτέ σε σωστές λύσεις.

    Η συνεισφορά αυτής της πτυχιακής έγκειται στον επαναορισμό κάποιων εκ των κανόνων της διαδικασίας απόδειξης της \hcn{}. Δείχνουμε ότι η νέα διαδικασία απόδειξης επιτρέπει την υλοποίηση ενός διερμηνευτή για την \hcn{}, o οποίος ακολουθεί τον κανόνα της PROLOG για επιλογή του πάντα αριστερότερου υποστόχου και παράλληλα συμπεριφέρεται σωστά (δίνει σωστές λύσεις μόνο) για κάθε επερώτηση.
  \end{greek}
}

\acksEn{
  \begin{greek}
    Στη σελίδα αυτή αναφέρονται οι ευχαριστίες. Η σελίδα αυτή είναι προαιρετική. Παρατίθεται παράδειγμα ευχαριστιών.

    Για τη διεκπεραίωση της παρούσας Πτυχιακής Εργασίας, θα θέλαμε να ευχαριστήσουμε τους επιβλέποντες, αν. καθ .Ευστράτιο Γεωργιάδη, Γρηγόριο Παπάμαλο, Αναστασία Γούσιου, Ξενοφών Παπαδόπουλο, για τη συνεργασία και την πολύτιμη συμβολή του στην ολοκλήρωση της.
  \end{greek}
}

\prefaceEn{
  This thesis constitutes my final step towards completing the undergraduate degree programme in the Department of Informatics and Telecommunications of the National and Kapodistrian University of Athens. It was carried out while working full-time in CERN, which added to the challenge.

  During the process of selecting and taking up a thesis subject, I encountered many interesting topics and had discussions with many professors. I would like to thank them all for their patience, cooperation and tips.

  The reason for selecting the current subject was that it was fascinating at first sight. I was no stranger to classical logic programming, however the concept of higher-order logic programming was something new for me.

  \hcn{} is a really expressive language. Its higher-order semantics allow one to write even some of the most complex predicates in a very elegant fashion. Of course the main property that enables such elegance is constructive negation, which is the principal feature of \hcn{}.

  \hcn{} borrows the semantics of constructive negation as defined by David Chan for the first-order case. It adapts them to the higher-order semantics of itself and does so perfectly in a theoretical level. However, implementing \hcn{} turned out to be a more challenging task than anticipated. The motivation behind this thesis is the identification and redefinition of those characteristics of the higher-order language \hcn{} that make it difficult for it to be implemented correctly.

  A correct implementation of \hcn{} shall then enable a whole world of applications to demonstrate themselves in solving interesting problems.
}

\inscriptionEn{
  \emph{Absence of evidence is not evidence of absence.} \\[8pt]
}

%
% Subject area and keywords
%
\subjectAreaGr{Λογικός Προγραμματισμός}
\subjectAreaEn{Logic Programming}
\keywordsGr{λογική, προγραμματισμός, άρνηση, υψηλή τάξη, εκτατικός}
\keywordsEn{logic, programming, negation, high-order, extensional}

%
% Set the .bib file containing your paper publications (leave the extension out)
%
% This is optional, but it should be specified when option 'lop' is passed to
% the document class.
%
% Then, inside the document environment, you may use the command '\nocitelop' to
% site your papers, as you would traditionally do with the commands '\cite' or
% '\nocite'.
%
% The papers are printed in reverse chronological order.
%
%\lopfile{mypapers/pubs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%% Required Metadata %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\frontmatter

\mainmatter

\chapter{INTRODUCTION}

\section{Extensional Higher-Order Logic Programming}

\section{Constructive Negation}


\chapter{THE HIGHER-ORDER LANGUAGE \hcn}

\section{Preliminaries}
The reader is presumed to be familiar with the basic concepts and definitions of classical Logic Programming \cite{Lloyd:1987:FLP:39279}. For example, the concepts \textbf{term}, \textbf{formula}, \textbf{atom}, \textbf{(program) clause} and \textbf{goal} are defined as in classical Logic Programming, with slight extensions on their definitions where necessary.

\section{Basic Definitions}

We begin by giving some definitions from the text where \hcn{} is defined \cite{DBLP:conf/kr/CharalambidisR14}, for the readers' convenience. These definitions are crucial to the understanding of the rest of the text.

\begin{definition}{\emph{Types}}

The type system of \hcn{} is based on two base types: $o$, the type of the boolean domain and $\iota$, the type of the individuals (data objects). For example, every classical logic programming term is of type $\iota$.

The types of \hcn{} are defined as follows:

\begin{center}
  \begin{tabular}{llll}
    $\sigma$ & $:=$ & $\iota ~~|~ \left( \iota \rightarrow \sigma \right)$ & \hspace*{2.5cm} \emph{(functional)} \\
    $\rho$   & $:=$ & $\iota ~~|~ \pi$ & \hspace*{2.5cm} \emph{(argument)} \\
    $\pi$    & $:=$ & $o ~~|~ \left( \rho \rightarrow \pi \right)$ & \hspace*{2.5cm} \emph{(predicate)} \\
  \end{tabular}
\end{center}

The argument type $\rho$ consists of the following subtypes:

\begin{center}
  \begin{tabular}{llll}
    $\mu$    & $:=$ & $\iota ~~|~ \kappa$ & \hspace*{2.5cm} \emph{(existential)} \\
    $\kappa$ & $:=$ & $\iota \rightarrow o ~~|~ \left( \iota \rightarrow \kappa \right)$ & \hspace*{2.5cm} \emph{(set)} \\
  \end{tabular}
\end{center}
\end{definition}

The operator \msf{\rightarrow} is right-associative.

Therefore, a functional type that is different from \msf{\iota} can also be written as \msf{\iota^n \rightarrow \iota}, \msf{n \ge 1}.
Similarly, a set type can also be written in the form \msf{\iota^n \rightarrow \mathnormal{o}}, \msf{n \ge 1}.
Finally, every predicate type $\pi$ can be written in the form \msf{\mathnormal{\rho}_1 \rightarrow \dots \rightarrow \mathnormal{\rho}_n \rightarrow \mathnormal{o}}, \msf{n \ge 0} (for \msf{n = 0} we assume that $\pi = o$).

\begin{definition}{\emph{Alphabet}}

The alphabet of \hcn{} consists of:
\begin{enumerate}
  \item \emph{Predicate variables} of every predicate type $\pi$.
  \item \emph{Predicate constants} of every predicate type $\pi$.
  \item \emph{Individual variables} of type $\iota$.
  \item \emph{Individual constants} of type $\iota$.
  \item \emph{Function symbols} of every functional type $\sigma \ne \iota$.
  \item The following logical constant symbols:
        \begin{enumerate}
          \item the \emph{propositional constants} \msf{false} and \msf{true}
                of type $o$;
          \item the \emph{equality constant} \msf{\approx}
                of type $\iota \rightarrow \iota \rightarrow o$;
          \item the \emph{generalised disjunction and conjunction constants} \msf{\bigvee_{\pi}} and \msf{\bigwedge_{\pi}}
                of type $\pi \rightarrow \pi \rightarrow \pi$,
                for every predicate type $\pi$;
          \item the \emph{equivalence constants} $\leftrightarrow_{\pi}$
                of type $\pi \rightarrow \pi \rightarrow o$,
                for every predicate type $\pi$;
          \item the \emph{existential quantifiers} $\exists_{\mu}$
                of type $\left( \mu \rightarrow o \right)$,
                for every existential type $\mu$;
          \item the \emph{negation constant} $\sim$ of type $o \rightarrow o$.
        \end{enumerate}
  \item The \emph{abstractor} $\lambda$ and the \emph{parentheses} ``\msf{(}'' and ``\msf{)}''.
\end{enumerate}

We define the set consisting of the predicate variables and the individual variables of \hcn{}, as the \emph{argument variables} of \hcn{}.
\end{definition}

\begin{definition}{\emph{Body expressions}}

The set of body expressions of \hcn{} is recursively defined as follows:
\begin{enumerate}
  \item
  \begin{enumerate}
    \item Every predicate variable (respectively, predicate constant) of type $\pi$ is a body expression of type $\pi$;
    \item Every individual variable (respectively, individual constant) of type $\iota$ is a body expression of type $\iota$;
    \item The propositional constants \msf{false} and \msf{true} are body expressions of type $o$.
  \end{enumerate}
  \item If \msf{f} is an \msf{n}-ary function symbol and \msf{E_1, \ldots, E_n} are body expressions of type $\iota$, then \msf{\left( f ~~ E_1 ~ \cdots ~ E_n \right)} is a body expression of type $\iota$.
  \item If \msf{E_1} is a body expression of type $\rho \rightarrow \pi$ and \msf{E_2} is a body expression of type $\rho$, then \msf{\left( E_1 ~ E_2 \right)} is a body expression of type $\pi$.
  \item If \msf{V} is an argument variable of type $\rho$ and \msf{E} is a body expression of type $\pi$, then \msf{\left( \lambda V. E \right)} is a body expression of type $\rho \rightarrow \pi$.
  \item If \msf{E_1, E_2} are body expressions of type $\pi$, then \msf{\left( E_1 \bigwedge_{\pi} E_2 \right)} and \msf{\left( E_1 \bigvee_{\pi} E_2 \right)} are body expressions of type $\pi$.
  \item If \msf{E_1, E_2} are body expressions of type $\iota$, then \msf{\left( E_1 \approx E_2 \right)} is a body expression of type $o$.
  \item If \msf{E} is a body expression of type $o$ and \msf{V} is an existential variable of type $\mu$, then \msf{\left( \exists_{\mu} V ~ E \right)} is a body expression of type $o$.
  \item If \msf{E} is a body expression of type $o$, then \msf{\left( \sim E \right)} is a body expression of type $o$.
\end{enumerate}
\end{definition}

The notions of \emph{free} and \emph{bound} variables are defined as usual. A body expression is called \emph{closed} if it does not contain any free variables.

In the following, we will write \msf{\widehat{A}} to denote a (possibly empty) sequence \msf{\langle A_1, \ldots, A_n \rangle}.

A body expression of the form \msf{\left( E_1 \approx E_2 \right)} will be called an \emph{equality}, while a body expression of the form \msf{\sim \exists \widehat{V} \left( E_1 \approx E_2 \right)} will be called an \emph{inequality}; in the latter case \msf{\widehat{V}} may be empty, in which case the inequality is of the form \msf{\sim \left( E_1 \approx E_2 \right)}.

Let \msf{\widehat{E}} and \msf{\widehat{E}'}, where all \msf{E_i}, \msf{E_i'} are of type $\iota$. We will write \msf{\left( \widehat{E} \approx \widehat{E}' \right)} to denote the expression \msf{\left( E_1 \approx E_1' \right) \land \dots \land \left( E_n \approx E_n' \right)}; if \msf{n = 0}, then the conjunction is the constant \msf{true}.

\begin{definition}{\emph{Clausal expressions}}

The set of clausal expressions of \hcn{} is defined as follows:
\begin{enumerate}
  \item If \msf{p} is a predicate constant of type $\pi$ and \msf{E} is a closed body expression of type $\pi$, then \msf{p \leftarrow_{\pi} E} is a clausal expression of \hcn{}, also called a \emph{program clause}.
  \item if \msf{E} is a body expression of type $o$ and each free variable in \msf{E} is of type $\mu$ (existential), then \msf{false \leftarrow_{o} E} (or \msf{\leftarrow_{o} E}, or just \msf{\leftarrow E} is a clausal expression of \hcn{}, also called a \emph{goal clause}.
  \item If \msf{p} is a predicate constant of type $\pi$ and \msf{E} is a closed body expression of type $\pi$, then \msf{p \leftrightarrow_{\pi} E} is a clausal expression of \hcn{}, also called a \emph{completion expression}.
\end{enumerate}

All clausal expressions of \hcn{} have type $o$.
\end{definition}

\begin{definition}{\emph{Program}}

A program of \hcn{} is a finite set of program clauses of \hcn{}.
\end{definition}

\begin{definition}{\emph{Completed definition of predicate}}

Let \msf{P} be a program and let \msf{p} be a predicate constant of type $\pi$. Then, the \emph{completed definition} for \msf{p} with respect to \msf{P} is obtained as follows:
\begin{itemize}
  \item if there exist exactly \msf{k > 0} program clauses of the form \msf{p \leftarrow_{\pi} E_{i}}, where \msf{i \in \left\{ 1, \ldots, k \right\}} for \msf{p} in \msf{P}, then the completed definition for \msf{p} is the expression \msf{p \leftrightarrow_{\pi} E}, where \msf{E = E_1 \bigvee_{\pi} \cdots \bigvee_{\pi} E_k}.
  \item if there are no program clauses for \msf{p} in \msf{P}, then the completed definition for \msf{p} is the expression \msf{p \leftrightarrow_{\pi} E}, where \msf{E} is of type $\pi$ and \msf{E = \lambda \widehat{X}.false}.
\end{itemize}

The expression \msf{E} on the right-hand side of the completed definition of \msf{p} will be called the \emph{completed expression} for \msf{p} with respect to \msf{P}.
\end{definition}

\begin{definition}{\emph{Completion of program}}

Let \msf{P} be a program. Then, the \emph{completion} \msf{comp(P)} of \msf{P} is the set consisting of all the completed definitions for all predicate constants that appear in \msf{P}.
\end{definition}

\chapter{THE PROOF PROCEDURE}
The proof procedure of \hcn{} incorporates and adapts the constructive negation rules, as described by David Chan in \cite{DBLP:conf/slp/Chan89}, to the higher-order case.

\section{The procedure}
In this section, we define the proof procedure, as proposed by Charalambidis et al. in \cite{DBLP:conf/kr/CharalambidisR14}. The procedure consists of three definitions. Definition \ref{singlestepderivation}...

\begin{definition}{\emph{Single-step derivation}}\label{singlestepderivation}

Let \msf{P} be a program and let \msf{G_{k}} and \msf{G_{k+1}} be goal clauses.

Let \msf{G_{k}} be a conjunction \msf{\leftarrow A_1 \land \dots \land A_n}, where each \msf{A_i} is a body expression of type $o$.

Let \msf{A_i} be one of \msf{A_1, \ldots, A_n} and let us call it the \emph{selected expression}.

Let \msf{A' = A_1 \land \dots \land A_{i-1} \land A_{i+1} \land \dots \land A_n}.

We say that \msf{G_{k+1}} \emph{is derived in one step} from \msf{G_k} using \msf{\theta}, if one of the following conditions applies:

\begin{enumerate}
  \item if \msf{A_i} is \msf{true} and \msf{n > 1},
        then \msf{G_{k+1} = \leftarrow A'} is derived from \msf{G_k}
        using \msf{\theta = \epsilon};
  \item if \msf{A_i} is \msf{\left( E_1 \lor E_2 \right)},
        then \msf{G_{k+1} = \leftarrow A_1 \land \dots \land E_j \land \dots \land A_n} is derived from \msf{G_k}
        using \msf{\theta = \epsilon}, where \msf{j \in \{1,2\}};
  \item if \msf{A_i} is \msf{\left( \exists V ~ E \right)},
        then \msf{G_{k+1} = \leftarrow A_1 \land \dots \land E \land \dots \land A_n} is derived from \msf{G_k} using \msf{\theta = \epsilon};
  \item if \msf{A_i \rightsquigarrow A_i'}, namely \msf{A_i} is reduced to \msf{A_i'},
        then \msf{G_{k+1} = \leftarrow A_1 \land \dots \land A_i' \land \dots \land A_n} is derived from \msf{G_k} using \msf{\theta = \epsilon};
  \item if \msf{A_i} is \msf{\left( E_1 \approx E_2 \right)},
        then \msf{G_{k+1} = \leftarrow A' \theta} is derived from \msf{G_k} using \msf{\theta = mgu \left( E_1, E_2 \right)};
  \item if \msf{A_i} is \msf{\left( R ~ \widehat{E} \right)}
        and \msf{R} is a predicate variable of type \msf{\kappa}
        then \msf{G_{k+1} = \leftarrow A' \theta} is derived from \msf{G_k}
        using \msf{\theta = \left\{ R \middle/ \left( \lambda \widehat{X} . \left( \widehat{X} \approx \widehat{E} \right) \bigvee_{\kappa} R' \right) \right\}},
        where \msf{R'} is a fresh predicate variable of type \msf{\kappa};
  \item if \msf{A_i} is \msf{\sim \exists \widehat{V} ~ E}
        and \msf{A_i} is negatively-reduced to \msf{A_i'}, \\
        then \msf{G_{k+1} = \leftarrow A_1 \land \dots \land A_i' \land \dots \land A_n} is derived from \msf{G_k} using \msf{\theta = \epsilon};
  \item if \msf{A_i} is \msf{\sim \exists \widehat{V} \left( R ~ \widehat{E} \right)}
        and \msf{R} is a predicate variable of type \msf{\kappa}
        and \msf{R \not\in \widehat{V}}, \\
        then \msf{G_{k+1} = \leftarrow A' \theta} is derived from \msf{G_k}
        using \msf{\theta = \left\{ R \middle/ \left( \lambda \widehat{X} . \sim \exists \widehat{V} \left( \widehat{X} \approx \widehat{E} \right) \bigwedge_{\kappa} R' \right) \right\}},
        where \msf{R'} is a fresh predicate variable of type \msf{\kappa};
  \item is \msf{A_i} is \msf{\sim \exists \widehat{V} \sim \left( R ~ \widehat{E} \right)}
        and \msf{R} is a predicate variable of type \msf{\kappa}
        and \msf{R \not\in \widehat{V}}, \\
        then \msf{G_{k+1} = \leftarrow A' \theta} is derived from \msf{G_k}
        using \msf{\theta = \left\{ R \middle/ \left( \lambda \widehat{X} . ~ \exists \widehat{V} \left( \widehat{X} \approx \widehat{E} \right) \bigvee_{\kappa} R' \right) \right\}}.
\end{enumerate}

\end{definition}

\begin{definition}{\emph{Reduction}}

Let \msf{P} be a program and \msf{E}, \msf{E'} be body expressions of type $o$.

We say that \msf{E} is reduced (with respect to \msf{P}) to \msf{E'} (denoted as \msf{E \rightsquigarrow E'}) if one of following conditions applies:

\begin{enumerate}
  \item \msf{p ~ \widehat{A} \rightsquigarrow E ~ \widehat{A}}, where \msf{E} is the completed expression for \msf{p} with respect to \msf{P};
  \item \msf{\left( \lambda X. E \right) B ~ \widehat{A} \rightsquigarrow E\left\{ X / B \right\} \widehat{A}};
  \item \msf{\left( E_1 \bigvee_{\pi} E_2 \right) \widehat{A} \rightsquigarrow \left( E_1 ~ \widehat{A} \right) \lor_{o} \left( E_2 ~ \widehat{A}  \right)};
  \item \msf{\left( E_1 \bigwedge_{\pi} E_2 \right) \widehat{A} \rightsquigarrow \left( E_1 ~ \widehat{A} \right) \land_{o} \left( E_2 ~ \widehat{A}  \right)}.
\end{enumerate}

\end{definition}

\begin{definition}{\emph{Negative reduction}}

Let \msf{P} be a program and \msf{B}, \msf{B'} be body expressions where \msf{B = \sim \exists \widehat{U} \left( A_1 \land \dots \land A_n \right)} and each \msf{A_i} is a body expression except for conjunction.

Let \msf{A_i} be the selected expression and \msf{A' = A_1 \land \dots \land A_{i-1} \land A_{i+1} \land \dots \land A_n}.

Then, we say that \msf{B} is \emph{negatively-reduced} to \msf{B'} if one of the following conditions applies:

\begin{enumerate}
  \item if \msf{A_i} is \msf{false}, then \msf{B' = true};
  \item if \msf{A_i} is \msf{true} and \msf{n = 1}, then \msf{B' = false},
        else \msf{B' = \sim \exists \widehat{U} ~ A'};
  \item if \msf{A_i} is \msf{\left( E_1 \lor E_2 \right)},
        then \msf{B' = B_1' \land B_2'}, \\ where \msf{B_j' = \sim \exists \widehat{U} \left( A_1 \land \dots \land E_j \land \dots \land A_n \right)}, for \msf{j \in \{ 1, 2 \}};
  \item if \msf{A_i} is \msf{\left( \exists V ~ E \right)},
        then \msf{B' = \sim \exists \widehat{U} V \left( A_1 \land \dots \land E \land \dots \land A_n \right)};
  \item if \msf{A_i \rightsquigarrow A_i'}, namely \msf{A_i} is reduced to \msf{A_i'},
        then \msf{B' = \sim \exists \widehat{U} \left( A_1 \land \dots \land A_i' \land \dots \land A_n \right)};
  \item if \msf{A_i} is \msf{\left( E_1 \approx E_2 \right)}, then:
        \begin{enumerate}
          \item if \msf{\sim \exists \widehat{U} \left( E_1 \approx E_2 \right)}
                is valid, then \msf{B' = true};
          \item if \msf{\sim \exists \widehat{U} \left( E_1 \approx E_2 \right)}
                is non-valid and neither \msf{E_1} nor \msf{E_2} is a variable,
                \\then \msf{B' = \sim \exists \widehat{U} \left( A_1 \land \dots \land A_{i-1} \land \left( \widehat{X} \approx \widehat{X} \theta \right) \land A_{i+1} \land \dots \land A_n \right)},
                \\where \msf{\theta = unify \left( E_1, E_2 \right)} and \msf{\widehat{X} = dom\left( \theta \right)};
          \item if \msf{\sim \exists \widehat{U} \left( E_1 \approx E_2 \right)} is unsatisfiable and either \msf{E_1} or \msf{E_2} is a variable in \msf{\widehat{U}},
          \\then \msf{B' = \sim \exists \widehat{U} \left( A' \theta \right)}, where \msf{\theta = \{ X / E \}} and \msf{X} is the one expression that is a variable in \msf{\widehat{U}} and \msf{E} is the other;
          \item if \msf{\sim \exists \widehat{U} \left( E_1 \approx E_2 \right)}
                is primitive and \msf{n > 1}, \\
                then \msf{B' = \sim \exists \widehat{U}_1 ~ A_i \lor \exists \widehat{U}_1 \left( A_i ~\land \sim \exists \widehat{U}_2 ~ A' \right)}, where \msf{\widehat{U}_1} are the variables in \msf{\widehat{U}} that are free in \msf{A_i} and \msf{\widehat{U}_2} are the variables in \msf{\widehat{U}} not in \msf{\widehat{U}_1};
        \end{enumerate}
  \item if \msf{A_i} is \msf{\left( R ~ \widehat{E} \right)} and \msf{R} is a predicate variable, then:
        \begin{enumerate}
          \item if \msf{R \in \widehat{U}},
                then \msf{B' = \sim \exists \widehat{U}' \left( A' \theta \right)},
                where substitution \msf{\theta = \left\{ R \middle/ \left( \lambda X . \left( X \approx E \right) \bigvee_{\kappa} R' \right) \right\}}, \msf{R'} is a predicate variable of the same type as \msf{R} and \msf{\widehat{U}'} is the same as \msf{\widehat{U}}, only the variable \msf{R} has been replaced with \msf{R'};
          \item if \msf{R \not \in \widehat{U}} and \msf{n > 1},
                then \msf{B' = \sim \exists \widehat{U}_1 ~ A_i \lor \exists \widehat{U}_1 \left( A_i ~\land \sim \exists \widehat{U}_2 ~ A' \right) \land B},
                where \msf{\widehat{U}_1} are the variables in \msf{\widehat{U}} that are free in \msf{A_i} and \msf{\widehat{U}_2} are the variables in \msf{\widehat{U}} not in \msf{\widehat{U}_1};
        \end{enumerate}
  \item if \msf{A_i} is \msf{\sim \exists \widehat{V} ~ E} and \msf{A_i} is negatively-reduced to \msf{A_i'}, \\
        then \msf{B' = \sim \exists \widehat{U} \left( A_1 \land \dots \land A_i' \land \dots \land A_n \right)};
  \item if \msf{A_i} is a primitive inequality \msf{\sim \exists \widehat{V} \left( E_1 \approx E_2 \right)}, then:
        \begin{enumerate}
          \item if \msf{A_i} contains free variables in \msf{\widehat{U}} and \msf{A'} is a conjunction of primitive inequalities, then \msf{B' = \sim \exists \widehat{U} ~ A'};
          \item if \msf{A_i} does not contain any free variables in \msf{\widehat{U}}, then \msf{B' = \exists \widehat{V} \left( E_1 \approx E_2 \right) \lor \sim \exists \widehat{U} ~ A'};
        \end{enumerate}
  \item if \msf{A_i} is \msf{\sim \exists \widehat{V} \left( R ~ \widehat{E} \right)} and \msf{R \not\in \widehat{V}} is a predicate variable,
        then:
        \begin{enumerate}
          \item if \msf{R \in \widehat{U}},
                then \msf{B' = \sim \exists \widehat{U'} \left( A' \theta \right)},
                where substitution \\ \msf{\theta = \left\{ R \middle/ \left( \lambda X . \sim \exists \widehat{V} \left( X \approx E \right) \bigwedge_{\kappa} R' \right) \right\}},
                \msf{R'} is a predicate variable of the same type \msf{\kappa} as \msf{R}
                and \msf{\widehat{U}'} is the same as \msf{\widehat{U}}, only the variable \msf{R} has been replaced with \msf{R'};
          \item if \msf{R \not\in \widehat{U}} and \msf{n > 1},
                then \msf{B' = \sim \exists \widehat{U}_1 ~ A_i \lor \exists \widehat{U}_1 \left( A_i ~ \land \sim \exists \widehat{U}_2 ~ A' \right) \land B},
                where \msf{\widehat{U}_1} are the variables in \msf{\widehat{U}} that are free in \msf{A_i} and \msf{\widehat{U}_2} are the variables in \msf{\widehat{U}} not in \msf{\widehat{U}_1};
          \item if \msf{R \not\in \widehat{U}}, \msf{n = 1} and \msf{\widehat{V}} is non-empty, \\
                then \msf{B' = \exists \widehat{V} \sim \exists \widehat{U} \left( \sim \left( R ~ \widehat{E} \right) \land \sim \exists \widehat{V}' \left( R ~ \widehat{E}' \right) \right)};
        \end{enumerate}
  \item if \msf{A_i} is \msf{\sim \exists \widehat{V} \sim \left( R ~ \widehat{E} \right)} and \msf{R} is a predicate variable and \msf{R \not\in \widehat{V}}, then:
        \begin{enumerate}
          \item if \msf{R \in \widehat{U}},
                then \msf{B' = \sim \exists \widehat{U}' \left( A' \theta \right)},
                where substitution \\ \msf{\theta = \left\{ R \middle/ \left( \lambda X . \exists \widehat{V} \left( X \approx E \right) \bigvee_{\kappa} R' \right) \right\}},
                \msf{R'} is a predicate variable of the same type \msf{\kappa} as \msf{R} and \msf{\widehat{U}'} is the same as \msf{\widehat{U}}, only the variable \msf{R} has been replaced with \msf{R'};
          \item if \msf{R \not\in \widehat{U}} and \msf{n > 1},
                then \msf{B' = \sim \exists \widehat{U}_1 ~ A_i \lor \exists \widehat{U}_1 \left( A_i ~ \land \sim \exists \widehat{U}_2 ~ A' \right) \land B};
          \item if \msf{R \not\in \widehat{U}}, \msf{n = 1} and \msf{\widehat{V}} is non-empty, \\
                then \msf{B' = \exists \widehat{V} \sim \exists \widehat{U} \left( \left( R ~ \widehat{E} \right) \land \sim \exists \widehat{V}' \sim \left( R ~ \widehat{E}' \right) \right)}.
        \end{enumerate}
\end{enumerate}

\end{definition}

\section{The problem}

\chapter{THE PROPOSED APPROACH}

\chapter{CONCLUSION AND FUTURE WORK}

\backmatter

% abbreviations table
\abbreviations
\begin{center}
	\renewcommand{\arraystretch}{1.5}
	\begin{longtable}{ l @{\qquad} l }
	\toprule
	  HOPES ($\mathcal{H}$)    & Higher Order Prolog with Extensional Semantics \\
    \hcn{}   & HOPES with Constructive Negation \\
	\bottomrule
	\end{longtable}
\end{center}

% % appendix
% \begin{appendix}
% % mark the beginning of the appendix
% \appendixstartedtrue
%
% % add appendix line to ToC
% \phantomsection
% \addcontentsline{toc}{chapter}{APPENDICES}
%
% \chapter{FIRST APPENDIX}
%
% \end{appendix}

% manually include the bibliography
\bibliographystyle{plain}
\bibliography{references}
% include it also in ToC (do sth on your own)
\addcontentsline{toc}{chapter}{REFERENCES}

\end{document}
